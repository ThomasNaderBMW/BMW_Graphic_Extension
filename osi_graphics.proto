syntax = "proto2";

option optimize_for = SPEED;

import "osi_common.proto";
import "osi_environment.proto";
import "osi_version.proto";

package osi3;

//
// \brief This format describes the graphic-configuration made in the 
// simulation-master. So stand-alone graphicengines can work because of
// these information.
//
message Graphics
{
    //
    // The interface version used by the sender.
    //
    optional InterfaceVersion version = 1;
    
    // The data timestamp of the simulation environment. The zero time point is
    // arbitrary but must be identical for all messages.
    // Recommendation: Zero time point for start point of the simulation.
    //
    optional Timestamp timestamp = 2;

    // Opaque reference of a map.
    //
    // \note Origin and orientation of the map have to coincide with the
    // inertial coordinate frame of the ground truth.
    //
    // \note It is implementation-specific how map_reference is resolved.
    //
    optional string map_reference = 3;
    
    //
    // ToDo: Description
    //
    optional VisualizationMode visualization_mode = 4;
    
    //
    // Here is the main information about how a screen is configured.
    // E.g.: Place of the camera, screen-configuration, avatar information, ...
    //
    optional ScreenConfiguration screen_configuration = 5;
    
    //
    // ToDo: Description
    //
    optional VirtualRealityConfiguration virtual_reality_configuration = 6;
    
    //
    // ToDo: Description
    //
    repeated HMIComponentsConfiguration hmi_components_configuration = 7;

    // The mode of the visualization.
    //
    enum VisualizationMode
    {
        // The visualization mode is unknown.
        //
        VISUALIZATION_MODE_UNKNOWN = 0;

        // The visualization mode is another one.
        //
        VISUALIZATION_MODE_OTHER = 1;

        // The visualization mode is virtual-reality.
        //
        VISUALIZATION_MODE_VIRTUAL_REALITY = 2;

        // The visualization mode is single-screen.
        //
        VISUALIZATION_MODE_SINGLE_SCREEN = 3;
        
        // The visualization mode is multi-screen.
        //
        VISUALIZATION_MODE_MULTI_SCREEN = 4;
    }
    
    //Open:
    //Kopfposition
    // OSI-Env (Tageszeitentypen, Cloudspeed, Wettertypen, Cloudshadowintensity, Percipitation, TimeofDay) country_code
    // HUD Information
    // SPOUT plane
}

// 
// \brief ToDo: Description
//
message ScreenConfiguration
{    
    //
    // \brief ToDo: Description
    //
    repeated GraphicEngineConfiguration graphic_engine_configuration = 1;
    
    //
    // \brief ToDo: Description
    //
    repeated DisplayConfiguration display_configuration = 2;
    
    //
    // \brief ToDo: Description
    //
    repeated WindowConfiguration window_configuration = 3;
    
    //
    // \brief ToDo: Description
    //
    repeated ViewportConfiguration viewport_configuration = 4;
    
    //
    // ToDo: Description.
    //
    // Range: [0, 400]
    //
    // Unit: [%]
    //
    optional double super_sampling_configuration = 5;
    
    // 
    // \brief ToDo: Description
    //
    message GraphicEngineConfiguration
    {       
        //
        // ID of the graphic engine.
        //
        optional uint64 graphic_engine_id = 1;
    }

    // 
    // \brief ToDo: Description
    //
    message DisplayConfiguration
    {
        //
        // Defines on which display the window is placed.
        //
        optional uint64 used_by_graphic_engine_id = 1;
        
        //
        // ID of the display.
        //
        optional uint64 display_id = 2;
    }

    // 
    // \brief ToDo: Description
    //
    message WindowConfiguration
    {
        //
        // Defines on which display the window is placed.
        //
        optional uint64 placement_on_display_id = 1;
        
        //
        // ID of the window.
        //
        optional uint64 window_id = 2;
        
        //
        // Position x of the window inside a display.
        //
        optional double position_x = 3;

        //
        // Position y of the window inside a display.
        //
        optional double position_y = 4;

        //
        // Pixel-width in x of the window inside a display.
        //
        optional double size_x = 5;

        //
        // Pixel-height in y of the window inside a display.
        //
        optional double size_y = 6;
        
        //
        // This value can be used instead of size_x or size_y.
        //
        optional bool is_fullsize = 7;
    }
    
    // 
    // \brief ToDo: Description
    //
    message ViewportConfiguration
    {
        //
        // Defines on which window the viewport is placed.
        //
        optional uint64 placement_on_window_id = 1;
        
        //
        // ID of the viewport.
        //
        optional uint64 viewport_id = 2;
        
        //
        // Position x of the viewport inside a window.
        //
        optional double position_x = 3;

        //
        // Position y of the viewport inside a window.
        //
        optional double position_y = 4;

        //
        // Pixel-width in x of the viewport inside a window.
        //
        optional double size_x = 5;

        //
        // Pixel-height in y of the viewport inside a window.
        //
        optional double size_y = 6;
        
        //
        // This value can be used instead of size_x or size_y.
        //
        optional bool is_fullsize = 7;
        
        //
        // ToDo: Description.
        //
        optional ViewConfiguration view_configuration = 9;
    }
    
    // 
    // \brief Here is the main information how the view of the camera/watcher is configured.
    //
    message ViewConfiguration
    {
        //
        // If this value is false the position is absolute, so the view is fixed to the
        // point defined by the following parameters (position, orientation, ...).
        // If true the view is relative to a specific object, assigned to the id specified
        // by the second parameter. The position-parameter determines therefore the distance/offset
        // relative to the object.
        //
        optional bool is_position_relative = 1;
        
        //
        // If the position is relative, this parameter defines the distance/offset to which object
        // by id. The position of the object can be found in osi_vehicle or osi_groundtruth.
        //
        optional uint64 relative_to_id = 2;

        //
        // A cartesian 3D vector for the position, defined in osi_common.
        // This is the position where the view is placed absolute/relative.
        //
        // Unit: [m]
        //
        optional Vector3d position = 3;

        //
        // A 3D vector for the orientaion, defined in osi_common.
        // This is the orientation of the view.
        //
        // Unit: [rad]
        //
        optional Orientation3d orientation = 4;
        
        //
        // A 3D vector for the orientaion, defined in osi_common.
        // This is the orientation-rate of the view.
        //
        // Unit: [rad/s]
        //
        optional Orientation3d orientation_rate = 5;
        
        //
        // ToDo: Description.
        //
        optional double clipping_far = 6;
        
        //
        // ToDo: Description.
        //
        optional double clipping_near = 7;
        
        //
        // ToDo: Description.
        //
        optional int32 frustum = 8;

        //
        // Should the ego-vehicle been shown?
        // Useful if the camera is inside the ego-vehicle.
        //
        optional bool show_host_vehicle = 9;
        
        //
        // ToDo: Description.
        //
        optional Avatar avatar = 10;
    }
}

// 
// \brief ToDo: Description
//
message VirtualRealityConfiguration
{
    //
    // ToDo: Description - diagonal
    //
    // Unit: [mm]
    //
    optional double field_of_view_size = 1;
    
    //
    // ToDo: Description - degree
    //
    // Unit: []
    //
    optional double field_of_view_degree = 2;
    
    //
    // ToDo: Description
    //
    optional bool hmd_front_camera_enabled = 3;

    //
    // Is it a vulnerable road user (e.g. pedestrian)?
    //
    optional bool is_vulnerable_road_user = 4;

    //
    // Is teleporting available?
    //
    optional bool is_teleporting_available = 5;
    
    //
    // Is the motion compensation enabled?
    //
    optional bool motion_compensation_enabled = 6;
    
    //
    // Is the HMD-calibration enabled?
    //
    optional bool hmd_calibration_enabled = 7;
}

// 
// \brief ToDo: Description
//
message HMIComponentsConfiguration
{
    // Some open points:
    // Kombi Config
             //bool DashBoardEnable;
             //FString DashBoardURL;
             //FVector2D DashBoardCanvas;
             //FVector2D DashBoardSize;
             //FVector2D DashBoardOffset;
             //FVector2D DashBoardScale;
             //FVector2D DashBoardCanvasLength;
    // CID Config
             //bool LEDEnable;
             //FString LEDURL;
             //FVector2D LEDCanvas;
             //FVector2D LEDSize;
             //FVector2D LEDOffset;
             //FVector2D LEDScale;
             //FVector2D LEDLength;
}

// 
// \brief ToDo: Description. SkinColor, ID necessary?
//
message Avatar
{             
    //
    // Should the ego-avatar been shown?
    // Useful for VR-Applications.
    //
    optional bool show_host_avatar = 1;

    //
    // ToDo: Description
    //
    optional Gender gender = 2;

    // The gender of the avatar.
    //
    enum Gender
    {
        // The gender is unknown.
        //
        GENDER_UNKNOWN = 0;

        // It is another gender.
        //
        GENDER_OTHER = 1;

        // The gender is female.
        //
        GENDER_FEMALE = 2;

        // The gender is male.
        //
        GENDER_MALE = 3;
    }
}
